import pytest

from app.schemas.pydantic_models import ProfilePydantic, ProfileUpdatePydantic


@pytest.fixture
def profile_data():
    """
        Sample profile data recorded in DB, for testing.
        Default scope="function" as no specified: it will be executed before every single test function.
        Changes in other functions will not affect subsequent test functions because each test gets its own fresh copy.
    """
    return {
        "id": 1,
        "created_at": "2025-01-01T00:00:00",
        "name": "Test Profile",
        "performance_type": "Test performance_type",
        "description": "Test description",
        "bio": "Test Bio",
        "social_media": [],
        "stage_plan": None,
        "tech_rider": None,
        "photos": ['https://exmaple.com_1', 'https://exmaple_2.com'],
        "videos": ['https://exmaple.com', 'https://exmaple_2.com'],
        "audios": ['https://exmaple.com', 'https://exmaple_2.com'],
        "online_press": [{'title': 'Test Press Title','url': 'https://exmaple.com'}],
        "website": "https://testweb.com"  # make website optional.
    }

@pytest.fixture
def mock_profile(profile_data):
    """
        Create a mock profiler model from profile data.
        Default scope="function" as no specified. This means mock_profile will be created before every test function that requests it
        The result of instantiating ProfilePydantic with the sample data is then returned by the mock_profile fixture.
    """
    return ProfilePydantic(**profile_data)  # ** dictionary unpacking operator


@pytest.fixture
def profile_data_to_update():
    """
        Sample profile data for testing an update.
        Default scope="function" as no specified: it will be executed before every single test function.
        This fixture should ideally contain *changes* from the original profile_data to simulate an update.
    """
    return {
        "name": "Updated Profile Name",
        "description": "This is an updated description.",
        "website": "https://updated_website.com"
    }

@pytest.mark.usefixtures("setup_common_dependencies_override", "setup_db_and_datamanager_override")
class TestProfileEndpoints:

    def test_create_profile(self, test_client, mock_data_manager, mock_db, mock_auth_user):
        """Test profile creation endpoint."""
        """
        Sample profile data for testing.
        Changes in other functions will not affect subsequent test functions because each test gets its own fresh copy.
    """
        # Setup
        mock_profile_id = 123
        mock_data_manager.create_profile.return_value = mock_profile_id
        profile_data = {
            "name": "Test Profile",
            "performance_type": "Test performance",
            "description": "Test Description",
            "bio": "Test Biography",
            "photos": [],
            "videos": [],
            "audios": [],
            "online_press": [],
            "website": None
        }

        # Execute
        response = test_client.post(
            "/profile",
            headers={"Authorization": "Bearer fake.jwt.token"},
            json=profile_data
        )

        # Verify
        assert response.status_code == 200
        assert response.json() == {"profile_id": mock_profile_id}
        mock_data_manager.create_profile.assert_called_once()

        # Verify profile data was passed correctly
        call_args = mock_data_manager.create_profile.call_args
        assert call_args[0][0].name == profile_data["name"]
        assert call_args[0][1] == mock_auth_user.id
        assert call_args[0][2] == mock_db

        # New: Use assert_called_with for create_profile
        # Create a Pydantic object from the input data, as the actual
        # function likely receives a Pydantic model.
        expected_profile_model = ProfilePydantic(
            id=None,  # ID is usually generated by DB, so expect None or omit if not required by the function signature
            created_at=None,  # Created_at is usually generated by DB, so expect None or omit
            **profile_data  # Unpack the rest of the data
        )

        mock_data_manager.create_profile.assert_called_with(
            # The first argument is likely a Pydantic model built from the JSON input
            # We can create a Pydantic instance to match the expected call.
            # If your create_profile function takes a dict directly, use profile_data here.
            # Assuming it takes a ProfilePydantic object:
            expected_profile_model,
            mock_auth_user.id,
            mock_db
        )


    def test_get_profile(self, test_client, mock_data_manager, mock_db, profile_data, mock_profile):
        """Get profile by iD
            test_client: The TestClient instance for making HTTP requests to the FastAPI app. (Likely defined as TestClient(app)).
            mock_data_manager: The MagicMock(spec=SQLAlchemyDataManager) instance.
            mock_db: The MagicMock() instance (representing a database session).
            profile_data: The dictionary containing sample profile data.
            mock_profile: The ProfilePydantic model instance, created from profile_data.
        """
        #Setup
        profile_id = 1
        mock_data_manager.get_profile_by_id.return_value = mock_profile
        """ It tells the mock_data_manager that when its get_profile_by_id method is called, it should return the mock_profile Pydantic object.
        """

        # Execute
        """ This simulates a client """
        response = test_client.get(f"/profile/{profile_id}")
        """ 
            The test_client is used to send a simulated GET request to the /profile/{profile_id} endpoint of the FastAPI application. 
            Because setup_db_and_datamanager_override has overridden the application's dependencies, 
            when the API route for /profile/{profile_id} internally calls get_db and get_data_manager (which then likely calls mock_data_manager.get_profile_by_id), 
            it will receive the pre-configured mock_data_manager and its behavior. 
            The mock returns the mock_profile object as configured in the Arrange phase.
        """

        # Verify
        assert response.status_code == 200
        response_data = response.json()
        assert response_data == mock_profile.model_dump(mode='json') # Use model_dump to compare Pydantic with JSON

        # Verify get_profile_by_id was called with the correct arguments
        mock_data_manager.get_profile_by_id.assert_called_once_with(
            profile_id,
            mock_db
        )


    def test_update_profile(self, test_client, mock_data_manager, mock_db, mock_auth_user, profile_data_to_update, mock_profile):
        """ Test update profile """
        # Setup
        profile_id_to_update = 123  # The ID from the URL

        # Create an expected Pydantic object that reflects the *result* of the update
        # This combines the original mock_profile's data with the changes from profile_data_to_update.
        # We also set the ID to match what the endpoint expects.
        expected_returned_profile = mock_profile.model_copy(update=profile_data_to_update)
        # Ensure the ID matches the one being updated in the URL
        expected_returned_profile.id = profile_id_to_update

        mock_data_manager.update_profile.return_value = expected_returned_profile

        # Execute
        response = test_client.put(
            f"/profile/{profile_id_to_update}",  # Use the actual ID here
            headers={"Authorization": "Bearer fake.jwt.token"},
            json=profile_data_to_update  # Send the data for updating
        )

        # Verify
        assert response.status_code == 200
        assert response.json() == expected_returned_profile.model_dump(mode='json')

        #Create a Pydantic model that matches the structure `update_profile`
        # method expects for the data to be updated.
        expected_update_payload = ProfileUpdatePydantic(**profile_data_to_update)

        mock_data_manager.update_profile.assert_called_once_with(
            # The order of arguments to the mocked method matters for assert_called_with.
            profile_id_to_update,
            expected_update_payload,  # `update_profile` expects a ProfileUpdatePydantic model
            mock_auth_user.id,  # Ensure the user ID is passed
            mock_db
        )

